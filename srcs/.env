# MariaDB config
MARIA_DATABASE=maria_data
MARIA_USER=abdessamed    

# WordPress database config
WP_DB_NAME=maria_data        
WP_DB_USER=abdessamed        
WP_DB_HOST=mariadb           

# WordPress admin config
WP_ADMIN_USER=aait-lha
WP_ADMIN_EMAIL=aait-lha@gmail.com

# WordPress user config
WP_USER=abdessamed
WP_USER_EMAIL=abdessamed@gmail.com
WP_USER_ROLE=editor

TITLE=simple page

FTP_USER=abdessamed

DOMAINE_NAME=aait-lha



# docker (CLI): Just a front-end tool

# dockerd: The actual daemon, handling requests

# containerd: A container runtime interface (used by dockerd)

# runc: The low-level OCI runtime that actually executes containers (via syscalls)

# CDM: docker run image
#    => docker cli sent the request to the dockerd
#    => if the image is not availavle locally it pulls it from docker registry



# docker run nginx
      
# [docker CLI]
      
# [dockerd (API server & manager)]
      
# [containerd (container lifecycle manager)]
      
# [runc (spawns container using Linux syscalls)]


# runc Sets Up:
# Namespaces: isolates process ID, filesystem, network, etc.

# Cgroups: applies CPU, memory, I/O limits

# Mounts: sets up rootfs and virtual filesystems like /proc, /dev, /sys

# Seccomp: filters syscalls (like a mini firewall for syscalls)

# Capabilities: drops unneeded root privileges

# AppArmor/SELinux: applies mandatory access controls

# User mappings: enables user namespace remapping (for rootless containers)

# Clone + Exec: spawns the actual containerized process

# What really happens:

# docker CLI formats a REST API call

# Sends it via HTTP over the Unix socket

# dockerd receives and processes the request

# Responds with JSON data (e.g. list of containers)
